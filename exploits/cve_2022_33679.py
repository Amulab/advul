import logging

from certipy.lib.target import Target

import datetime
import random

from impacket.krb5 import constants
from impacket.krb5.asn1 import AS_REQ, KERB_PA_PAC_REQUEST, seq_set, seq_set_iter
from impacket.krb5.kerberosv5 import sendReceive, KerberosError
from impacket.krb5.types import Principal, KerberosTime
from pyasn1.codec.der import encoder
from pyasn1.type.univ import noValue

from advul.lib.runner import Runner

try:
    rand = random.SystemRandom()
except NotImplementedError:
    rand = random
    pass


def has_33679(user, domain, kdcHost):
    asReq = AS_REQ()
    domain = domain.upper()
    serverName = Principal('krbtgt/%s' % domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
    clientName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

    pacRequest = KERB_PA_PAC_REQUEST()
    pacRequest['include-pac'] = True
    encodedPacRequest = encoder.encode(pacRequest)

    asReq['pvno'] = 5
    asReq['msg-type'] = int(constants.ApplicationTagNumbers.AS_REQ.value)

    asReq['padata'] = noValue
    asReq['padata'][0] = noValue
    asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)
    asReq['padata'][0]['padata-value'] = encodedPacRequest

    reqBody = seq_set(asReq, 'req-body')

    opts = list()
    opts.append(constants.KDCOptions.forwardable.value)
    opts.append(constants.KDCOptions.renewable.value)
    opts.append(constants.KDCOptions.proxiable.value)
    reqBody['kdc-options'] = constants.encodeFlags(opts)

    seq_set(reqBody, 'sname', serverName.components_to_asn1)
    seq_set(reqBody, 'cname', clientName.components_to_asn1)

    reqBody['realm'] = domain

    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)
    reqBody['till'] = KerberosTime.to_asn1(now)
    reqBody['rtime'] = KerberosTime.to_asn1(now)
    reqBody['nonce'] = rand.getrandbits(31)

    # 设置默认的加密方式为RC4-MD4(-128)
    supportedCiphers = (-128,)
    seq_set_iter(reqBody, 'etype', supportedCiphers)

    message = encoder.encode(asReq)

    try:
        r = sendReceive(message, domain, kdcHost)
        # 正常的错误应该是error-code: eRR-PREAUTH-REQUIRED (25)
        # 这种情况下不会抛出异常，说明目标接受 RC4-MD4
        return True
    except KerberosError as e:
        if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
            return False
        else:
            raise


class CVE202233679(Runner):
    def __init__(self, target: Target, **kwargs):
        """
            33679漏洞检测
            必要条件：
                1. 一个域内存在的用户（非禁用状态）
                2. 域名
                3. 域控ip
            python依赖：
                1. impacket
                2. certipy
            """
        super().__init__(target=target,
                         required_params=['username', 'domain', 'dc_ip'],
                         **kwargs)
        self._target = target
        self._opts = kwargs

    def run(self, target_ip=None):
        if target_ip is not None:
            target_ip = target_ip
        else:
            target_ip = self._target.dc_ip
        try:
            if has_33679(self._target.username, self._target.domain, target_ip):
                logging.info(f'[{target_ip}] has 33679')
            else:
                logging.info(f'[{target_ip}] is not vuln')
        except Exception as e:
            logging.error(f'[{target_ip}] {e}')


if __name__ == '__main__':
    logging.getLogger().setLevel(logging.INFO)

    domain = 'jd.local'
    username = 'DC01'
    dc_ip = '192.168.31.111'

    t = Target.create(domain=domain, username=username, dc_ip=dc_ip, no_pass=True)
    runner = CVE202233679(t)
    # 单机扫描
    runner.run()
    # 批量扫描（自动）
    runner.run_multi()
    # 批量扫描（手动）
    runner.run_multi("""192.168.31.110
    192.168.31.111""".split('\n'))
