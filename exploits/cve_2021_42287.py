import datetime
import logging
import struct
from binascii import unhexlify
import random

from certipy.lib.target import Target
from impacket.krb5 import constants
from impacket.krb5.asn1 import AS_REP, AP_REQ, seq_set, Authenticator, \
    TGS_REQ, PA_FOR_USER_ENC, Ticket as TicketAsn1, seq_set_iter, TGS_REP, EncTicketPart, AD_IF_RELEVANT
from impacket.krb5.crypto import _HMACMD5, Key, Enctype, _enctype_table
from impacket.krb5.kerberosv5 import getKerberosTGT, sendReceive
from impacket.krb5.pac import PACTYPE, PAC_INFO_BUFFER
from impacket.krb5.types import Principal, KerberosTime, Ticket
from pyasn1.codec.der import decoder, encoder
from pyasn1.type.univ import noValue

from lib.runner import Runner


def get_pac(target: Target, kdc=None) -> bytes:
    userName = Principal(target.username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
    tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, target.password, target.domain,
                                                            unhexlify(target.lmhash), unhexlify(target.nthash), '',
                                                            kdc)
    decodedTGT = decoder.decode(tgt, asn1Spec=AS_REP())[0]

    # Extract the ticket from the TGT
    ticket = Ticket()
    ticket.from_asn1(decodedTGT['ticket'])

    apReq = AP_REQ()
    apReq['pvno'] = 5
    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

    opts = list()
    apReq['ap-options'] = constants.encodeFlags(opts)
    seq_set(apReq, 'ticket', ticket.to_asn1)

    authenticator = Authenticator()
    authenticator['authenticator-vno'] = 5
    authenticator['crealm'] = str(decodedTGT['crealm'])

    clientName = Principal()
    clientName.from_asn1(decodedTGT, 'crealm', 'cname')

    seq_set(authenticator, 'cname', clientName.components_to_asn1)

    now = datetime.datetime.utcnow()
    authenticator['cusec'] = now.microsecond
    authenticator['ctime'] = KerberosTime.to_asn1(now)

    if logging.getLogger().level == logging.DEBUG:
        logging.debug('AUTHENTICATOR')
        print(authenticator.prettyPrint())
        print('\n')
    encodedAuthenticator = encoder.encode(authenticator)

    # Key Usage 7
    # TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes
    # TGS authenticator subkey), encrypted with the TGS session
    # key (Section 5.5.1)
    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)

    apReq['authenticator'] = noValue
    apReq['authenticator']['etype'] = cipher.enctype
    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

    encodedApReq = encoder.encode(apReq)

    tgsReq = TGS_REQ()

    tgsReq['pvno'] = 5
    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)

    tgsReq['padata'] = noValue
    tgsReq['padata'][0] = noValue
    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)
    tgsReq['padata'][0]['padata-value'] = encodedApReq

    # In the S4U2self KRB_TGS_REQ/KRB_TGS_REP protocol extension, a service
    # requests a service ticket to itself on behalf of a user. The user is
    # identified to the KDC by the user's name and realm.
    clientName = Principal(target.username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

    S4UByteArray = struct.pack('<I', constants.PrincipalNameType.NT_PRINCIPAL.value)
    S4UByteArray += (target.username + target.domain).encode() + b'Kerberos'

    # Finally cksum is computed by calling the KERB_CHECKSUM_HMAC_MD5 hash
    # with the following three parameters: the session key of the TGT of
    # the service performing the S4U2Self request, the message type value
    # of 17, and the byte array S4UByteArray.
    checkSum = _HMACMD5.checksum(sessionKey, 17, S4UByteArray)

    paForUserEnc = PA_FOR_USER_ENC()
    seq_set(paForUserEnc, 'userName', clientName.components_to_asn1)
    paForUserEnc['userRealm'] = target.domain
    paForUserEnc['cksum'] = noValue
    paForUserEnc['cksum']['cksumtype'] = int(constants.ChecksumTypes.hmac_md5.value)
    paForUserEnc['cksum']['checksum'] = checkSum
    paForUserEnc['auth-package'] = 'Kerberos'

    if logging.getLogger().level == logging.DEBUG:
        logging.debug('PA_FOR_USER_ENC')
        print(paForUserEnc.prettyPrint())

    encodedPaForUserEnc = encoder.encode(paForUserEnc)

    tgsReq['padata'][1] = noValue
    tgsReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_FOR_USER.value)
    tgsReq['padata'][1]['padata-value'] = encodedPaForUserEnc

    reqBody = seq_set(tgsReq, 'req-body')

    opts = list()
    opts.append(constants.KDCOptions.forwardable.value)
    opts.append(constants.KDCOptions.renewable.value)
    opts.append(constants.KDCOptions.renewable_ok.value)
    opts.append(constants.KDCOptions.canonicalize.value)
    opts.append(constants.KDCOptions.enc_tkt_in_skey.value)

    reqBody['kdc-options'] = constants.encodeFlags(opts)

    serverName = Principal(target.username, type=constants.PrincipalNameType.NT_UNKNOWN.value)
    # serverName = Principal('krbtgt/%s' % domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)

    seq_set(reqBody, 'sname', serverName.components_to_asn1)
    reqBody['realm'] = str(decodedTGT['crealm'])

    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)

    reqBody['till'] = KerberosTime.to_asn1(now)
    reqBody['nonce'] = random.getrandbits(31)
    seq_set_iter(reqBody, 'etype',
                 (int(cipher.enctype), int(constants.EncryptionTypes.rc4_hmac.value)))

    # If you comment these two lines plus enc_tkt_in_skey as option, it is bassically a S4USelf
    myTicket = ticket.to_asn1(TicketAsn1())
    seq_set_iter(reqBody, 'additional-tickets', (myTicket,))

    if logging.getLogger().level == logging.DEBUG:
        logging.debug('Final TGS')
        print(tgsReq.prettyPrint())

    message = encoder.encode(tgsReq)

    r = sendReceive(message, target.domain, kdc)

    tgs = decoder.decode(r, asn1Spec=TGS_REP())[0]

    if logging.getLogger().level == logging.DEBUG:
        logging.debug('TGS_REP')
        print(tgs.prettyPrint())

    cipherText = tgs['ticket']['enc-part']['cipher']

    # Key Usage 2
    # AS-REP Ticket and TGS-REP Ticket (includes tgs session key or
    #  application session key), encrypted with the service key
    #  (section 5.4.2)

    newCipher = _enctype_table[int(tgs['ticket']['enc-part']['etype'])]

    # Pass the hash/aes key :P
    if target.nthash != '':
        key = Key(newCipher.enctype, unhexlify(target.nthash))
    else:
        if newCipher.enctype == Enctype.RC4:
            key = newCipher.string_to_key(target.password, '', None)
        else:
            key = newCipher.string_to_key(target.password, target.domain + target.username, None)

    try:
        # If is was plain U2U, this is the key
        plainText = newCipher.decrypt(key, 2, str(cipherText))
    except:
        # S4USelf + U2U uses this other key
        plainText = cipher.decrypt(sessionKey, 2, cipherText)

    return plainText


def check_pac(data):
    enc_ticket_part = decoder.decode(data, asn1Spec=EncTicketPart())[0]
    ad_if_relevant = decoder.decode(enc_ticket_part['authorization-data'][0]['ad-data'], asn1Spec=AD_IF_RELEVANT())[0]
    # So here we have the PAC
    pac_type = PACTYPE(ad_if_relevant[0]['ad-data'].asOctets())
    buff = pac_type['Buffers']
    new_pac_found = False
    for buffer_n in range(pac_type['cBuffers']):
        infoBuffer = PAC_INFO_BUFFER(buff)
        if logging.getLogger().level == logging.DEBUG:
            print("TYPE 0x%x" % infoBuffer['ulType'])
        if infoBuffer['ulType'] == 0x10:
            new_pac_found = True
        buff = buff[len(infoBuffer):]

    return new_pac_found


class CVE202142287(Runner):
    def __init__(self, target: Target, opts):
        """
            33679漏洞检测
            必要条件：
                1. 一个域内存在的用户（非禁用状态）
                2. 域名
                3. 域控ip
            python依赖：
                1. impacket
                2. certipy
            """
        super().__init__(target=target,
                         required_params=['username', ('hashes', 'password'), 'domain', 'dc_ip'])
        self._target = target
        self._opts = opts

    def run(self, target_ip=None):
        if target_ip is not None:
            target_ip = target_ip
        else:
            target_ip = self._target.dc_ip
        logging.debug(f'getting pac...')
        pac = get_pac(self._target, target_ip)
        if pac:
            logging.debug(f'pac got! check pac next.')
            if check_pac(pac):
                logging.info(f'[{target_ip}] is patched :<')
            else:
                logging.info(f'[{target_ip}] is vulnerable to 42287!!!!')
        else:
            logging.error(f'pac is empty, please check.<')


if __name__ == '__main__':
    t = Target.create(domain='jd.local', username='JDCA$', hashes='48f925772624af82147e750a45b912a8',
                      dc_ip='192.168.31.110')
    print(t)
    pac = get_pac(target=t, kdc='192.168.31.111')
    print(check_pac(pac))
